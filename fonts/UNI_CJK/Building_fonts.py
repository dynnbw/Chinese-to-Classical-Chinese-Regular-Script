#!/usr/bin/env fontforge
# -*- coding: utf-8 -*-
#F:\Documents\WEBEdit\Chinese-to-Classical-Chinese-Regular-Script\fonts\UNI_CJK>"C:\Program Files\FontForgeBuilds\bin\fontforge.exe" -script "F:\Documents\WEBEdit\Chinese-to-Classical-Chinese-Regular-Script\fonts\UNI_CJK\Building_fonts.py" -i "F:\Documents\WEBEdit\Chinese-to-Classical-Chinese-Regular-Script\fonts\UNI_CJK\SVG" -o "Unicode17_CJK.ttf"
"""
FontForge SVG批量转TTF工具（单批次版：移除分批导入，生成单个SFD）
运行方式：fontforge -script Building_fonts1.py -i ./SVG -o Unicode17_CJK.ttf
"""

import fontforge # 确保FontForge的Python环境可用
import os
import re
import sys
import json
import time
import argparse
from pathlib import Path
from typing import Dict, List, Tuple, Optional

# ==================== 全局配置 ====================
UNICODE_17_CJK_BLOCKS = {
    (0x4E00, 0x9FFF): "CJK Unified Ideographs (Common)",
    (0x3400, 0x4DBF): "CJK Unified Ideographs Extension A (Rare)",
    (0x20000, 0x2A6DF): "CJK Unified Ideographs Extension B (Rare, historic)",
    (0x2A700, 0x2B73F): "CJK Unified Ideographs Extension C (Rare, historic)",
    (0x2B740, 0x2B81F): "CJK Unified Ideographs Extension D (Urgently needed)",
    (0x2B820, 0x2CEAF): "CJK Unified Ideographs Extension E (Rare, historic)",
    (0x2CEB0, 0x2EBEF): "CJK Unified Ideographs Extension F (Rare, historic)",
    (0x30000, 0x3134F): "CJK Unified Ideographs Extension G (Rare, historic)",
    (0x31350, 0x323AF): "CJK Unified Ideographs Extension H (Rare, historic)",
    (0x2EBF0, 0x2EE5F): "CJK Unified Ideographs Extension I (Urgently needed)",
    (0x323B0, 0x3347F): "CJK Unified Ideographs Extension J (Rare, historic)",
    (0xF900, 0xFAFF): "CJK Compatibility Ideographs (Duplicates, variants)",
    (0x2F800, 0x2FA1F): "CJK Compatibility Ideographs Supp. (Unifiable variants)"
}

# ==================== 工具函数 ====================
def extract_unicode_from_filename(filename: str) -> Optional[int]:
    """从SVG文件名提取Unicode码点"""
    try:
        fname = Path(filename).stem.upper()
        if not re.match(r"^[0-9A-F]{4,6}$", fname):
            return None
        codepoint = int(fname, 16)
        if codepoint > 0x10FFFF:
            print(f"警告：码点{fname}超出Unicode范围")
            return None
        return codepoint
    except Exception as e:
        print(f"解析文件名失败 {filename}：{str(e)}")
        return None

def get_cjk_block(codepoint: int) -> str:
    """获取码点所属CJK区块"""
    for (start, end), name in UNICODE_17_CJK_BLOCKS.items():
        if start <= codepoint <= end:
            return name
    return "Other Characters"

def scan_svg_files(input_dir: str) -> Tuple[List[Tuple[str, int]], Dict[str, int], Dict[str, int]]:
    """递归扫描SVG文件，校验SVG非空"""
    valid_files = []
    block_stats = {name: 0 for _, name in UNICODE_17_CJK_BLOCKS.items()}
    block_stats["Other Characters"] = 0
    error_stats = {
        "invalid_filename": 0,
        "non_svg": 0,
        "duplicate_codepoint": 0,
        "empty_svg": 0,  # 空SVG文件
        "total_scanned": 0
    }
    codepoint_set = set()

    for root, _, files in os.walk(input_dir):
        for file in files:
            error_stats["total_scanned"] += 1
            file_path = os.path.join(root, file)

            # 过滤非SVG文件
            if not file.lower().endswith(".svg"):
                error_stats["non_svg"] += 1
                continue

            # 校验SVG是否为空（小于10字节视为空）
            if os.path.getsize(file_path) < 10:
                error_stats["empty_svg"] += 1
                print(f"警告：空SVG文件 {file_path}")
                continue

            # 提取码点
            codepoint = extract_unicode_from_filename(file)
            if codepoint is None:
                error_stats["invalid_filename"] += 1
                continue

            # 检测重复码点
            if codepoint in codepoint_set:
                error_stats["duplicate_codepoint"] += 1
                print(f"警告：重复码点 U+{codepoint:X}（{file_path}）")
                continue

            # 统计区块
            block_name = get_cjk_block(codepoint)
            block_stats[block_name] += 1

            valid_files.append((file_path, codepoint))
            codepoint_set.add(codepoint)

    valid_files.sort(key=lambda x: x[1])
    total_error = sum(v for k, v in error_stats.items() if k != 'total_scanned')
    print(f"扫描完成：总文件{error_stats['total_scanned']} | 有效{len(valid_files)} | 错误{total_error}")
    return valid_files, block_stats, error_stats

def create_fontforge_font(font_name: str, units_per_em: int = 1024) -> fontforge.font:
    """创建FontForge字体对象"""
    font = fontforge.font()
    font.fontname = font_name
    font.familyname = font_name
    font.fullname = f"{font_name} Regular"
    font.version = "1.0"
    font.copyright = "Generated by SVG2TTF (FontForge 2024+)"
    font.encoding = "UnicodeFull"
    font.em = units_per_em
    font.ascent = int(units_per_em * 0.85)
    font.descent = int(units_per_em * 0.15)
    return font

def validate_svg_outline(glyph: fontforge.glyph) -> bool:
    """校验字形是否包含有效轮廓"""
    try:
        # 检查字形是否有有效输出（全版本兼容）
        if glyph.isWorthOutputting():
            return True
        # 手动检查轮廓数量（兼容不同FontForge版本）
        try:
            contour_count = len(glyph.contours)
        except:
            contour_count = 0
        return contour_count > 0
    except:
        return False

def import_svg_to_font(font: fontforge.font, svg_path: str, codepoint: int, test_mode: bool = False) -> bool:
    """导入单个SVG文件到字体"""
    try:
        # 安全创建字形
        if codepoint not in font:
            glyph = font.createChar(codepoint)
        else:
            glyph = font[codepoint]
        glyph.clear()

        if test_mode:
            # 测试模式：绘制简单矩形（兼容不同API版本）
            try:
                glyph.moveTo(100, 100)
                glyph.lineTo(font.em - 100, 100)
                glyph.lineTo(font.em - 100, font.em - 100)
                glyph.lineTo(100, font.em - 100)
                glyph.closePath()
            except:
                # 兼容无moveTo的版本
                pass
        else:
            # 导入SVG轮廓（核心方法）
            glyph.importOutlines(svg_path)

        # 校验轮廓是否有效
        if not validate_svg_outline(glyph):
            print(f"\n导入失败 U+{codepoint:X}：SVG无有效轮廓")
            return False

        # 设置宽度
        glyph.width = font.em

        return True
    except Exception as e:
        print(f"\n导入失败 U+{codepoint:X}：{str(e)[:60]}...")
        return False

def import_all_svg(
    font: fontforge.font,
    valid_files: List[Tuple[str, int]],
    test_mode: bool = False,
    limit: int = 0
) -> Dict[str, int]:
    """一次性导入所有SVG文件（移除分批逻辑）"""
    # 限制处理数量（测试用）
    total_files = len(valid_files) if limit <= 0 else min(limit, len(valid_files))
    process_files = valid_files[:total_files]

    total_stats = {
        "total": total_files,
        "success": 0,
        "failed": 0
    }

    print(f"\n开始一次性导入：共{total_files}个SVG文件")
    
    # 遍历所有文件导入
    for idx, (svg_path, codepoint) in enumerate(process_files):
        if import_svg_to_font(font, svg_path, codepoint, test_mode):
            total_stats["success"] += 1
        else:
            total_stats["failed"] += 1

        # 每500个文件显示一次进度（避免刷屏）
        if (idx + 1) % 500 == 0:
            progress = (idx + 1) / total_files * 100
            print(f"\r进度：{progress:.1f}% | 成功{total_stats['success']} | 失败{total_stats['failed']}", end="")

    # 最终进度打印
    print(f"\r进度：100.0% | 成功{total_stats['success']} | 失败{total_stats['failed']}")
    print(f"\n全部导入完成！")
    print(f"总计：{total_stats['total']} | 成功：{total_stats['success']} | 失败：{total_stats['failed']}")
    print(f"成功率：{(total_stats['success']/total_stats['total'])*100:.2f}%")
    
    return total_stats

def generate_process_report(
    output_ttf_path: str,
    total_stats: Dict[str, int],
    block_stats: Dict[str, int],
    error_stats: Dict[str, int],
    process_time: float,
    font_name: str,
    units_per_em: int
) -> None:
    """生成处理报告"""
    report_data = {
        "基础信息": {
            "字体名称": font_name,
            "EM尺寸": units_per_em,
            "总耗时(秒)": f"{process_time:.2f}",
            "总耗时(小时)": f"{process_time/3600:.2f}",
            "生成时间": time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
        },
        "导入统计": total_stats,
        "Unicode区块分布": block_stats,
        "扫描错误统计": error_stats
    }

    json_report_path = f"{output_ttf_path}.report.json"
    with open(json_report_path, "w", encoding="utf-8") as f:
        json.dump(report_data, f, ensure_ascii=False, indent=4)

    txt_report_path = f"{output_ttf_path}.report.txt"
    with open(txt_report_path, "w", encoding="utf-8") as f:
        f.write("="*80 + "\n")
        f.write("SVG批量转TTF（FontForge 2024+）处理报告\n")
        f.write("="*80 + "\n\n")
        for section, data in report_data.items():
            f.write(f"【{section}】\n")
            for k, v in data.items():
                f.write(f"{k}: {v}\n")
            f.write("\n")

    print(f"\n  处理报告已保存：")
    print(f"   - JSON格式：{json_report_path}")
    print(f"   - 文本格式：{txt_report_path}")

# ==================== 主函数 ====================
def main():
    parser = argparse.ArgumentParser(description="FontForge 2024+ SVG批量转TTF（单批次版）")
    parser.add_argument("-i", "--input", required=True, help="SVG文件目录")
    parser.add_argument("-o", "--output", default="Unicode17_CJK.ttf", help="输出TTF文件路径")
    parser.add_argument("-n", "--font-name", default="Unicode17_CJK", help="字体名称")
    parser.add_argument("-u", "--units-per-em", type=int, default=1024, help="字体EM尺寸")
    parser.add_argument("-l", "--limit", type=int, default=0, help="限制处理文件数（测试用）")
    parser.add_argument("--test", action="store_true", help="测试模式")
    # 移除batch_size参数（不再分批）
    args = parser.parse_args()

    if not os.path.isdir(args.input):
        print(f"错误：输入目录不存在 → {args.input}")
        sys.exit(1)

    start_time = time.time()

    try:
        # 步骤1：扫描SVG文件
        print("=== 步骤1/4：扫描SVG文件 ===")
        valid_files, block_stats, error_stats = scan_svg_files(args.input)
        if not valid_files:
            print("错误：未找到任何有效SVG文件")
            sys.exit(1)

        # 步骤2：初始化字体
        print("\n=== 步骤2/4：初始化FontForge字体 ===")
        font = create_fontforge_font(args.font_name, args.units_per_em)
        print(f"字体初始化完成：名称={args.font_name} | EM尺寸={args.units_per_em}")

        # 步骤3：一次性导入所有SVG
        print("\n=== 步骤3/4：一次性导入所有SVG字形 ===")
        total_stats = import_all_svg(
            font, valid_files, args.test, args.limit
        )

        # 步骤4：生成最终TTF和单个SFD文件
        print("\n=== 步骤4/4：生成最终TTF和SFD文件 ===")
        output_ttf_fullpath = os.path.abspath(args.output)
        # 生成TTF（仅保留兼容的flag，避免报错）
        font.generate(
            output_ttf_fullpath,
            flags=(
                "no-hints", "no-flex", "opentype", "dummy-dsig", "round"
            )
        )
        # 生成单个SFD文件（核心：仅保留最终的SFD，无分批文件）
        final_sfd_path = f"{args.font_name}_final.sfd"
        font.save(final_sfd_path)
        print(f"单个SFD文件已保存：{final_sfd_path}")

        # 校验最终文件大小
        if os.path.exists(output_ttf_fullpath):
            file_size_mb = os.path.getsize(output_ttf_fullpath) / 1024 / 1024
            if file_size_mb < 1:
                print(f"警告：生成的TTF文件过小（{file_size_mb:.2f}MB），可能无有效数据")
            else:
                print(f"TTF字体生成完成 → {output_ttf_fullpath}")
                print(f"文件大小：{file_size_mb:.2f} MB")
        else:
            print(f"❌ 错误：TTF文件生成失败 → {output_ttf_fullpath}")
            sys.exit(1)

        # 生成处理报告
        process_total_time = time.time() - start_time
        generate_process_report(
            output_ttf_fullpath, total_stats, block_stats, error_stats,
            process_total_time, args.font_name, args.units_per_em
        )

        # 最终汇总
        print("\n" + "="*80)
        print("全部处理完成！核心汇总：")
        print(f"总耗时：{process_total_time:.2f} 秒（{process_total_time/3600:.2f} 小时）")
        print(f"处理文件：{total_stats['total']} | 成功：{total_stats['success']} | 失败：{total_stats['failed']}")
        print(f"成功率：{(total_stats['success']/total_stats['total'])*100:.2f}%")
        print(f"最终字体：{output_ttf_fullpath}")
        print(f"单个SFD文件：{final_sfd_path}")
        print(f"TTF大小：{os.path.getsize(output_ttf_fullpath)/1024/1024:.2f} MB")
        print("="*80)

    except Exception as e:
        print(f"\n❌ 致命错误：{str(e)}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    try:
        import multiprocessing
        multiprocessing.freeze_support()
    except:
        pass
    main()